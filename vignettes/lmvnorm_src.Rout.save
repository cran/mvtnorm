
> year <- substr(packageDescription("mvtnorm")$Date, 
+     1, 4)

> version <- packageDescription("mvtnorm")$Version

> options(digits = 4)

> chk <- function(...) stopifnot(isTRUE(all.equal(...)))

> library("mvtnorm")

> set.seed(290875)

> N <- 4

> J <- 5

> rn <- paste0("C_", 1:N)

> nm <- LETTERS[1:J]

> Jn <- J * (J - 1)/2

> xn <- matrix(runif(N * Jn), ncol = N)

> colnames(xn) <- rn

> xd <- matrix(runif(N * (Jn + J)), ncol = N)

> colnames(xd) <- rn

> (lxn <- ltMatrices(xn, byrow = TRUE, names = nm))
, , C_1

        A      B       C      D E
A 1.00000 0.0000 0.00000 0.0000 0
B 0.51237 1.0000 0.00000 0.0000 0
C 0.05847 0.9095 1.00000 0.0000 0
D 0.39449 0.6612 0.23353 1.0000 0
E 0.51648 0.2980 0.07518 0.8182 1

, , C_2

       A      B      C      D E
A 1.0000 0.0000 0.0000 0.0000 0
B 0.8591 1.0000 0.0000 0.0000 0
C 0.3744 0.1023 1.0000 0.0000 0
D 0.1165 0.7957 0.8931 1.0000 0
E 0.1948 0.4730 0.2378 0.2146 1

, , C_3

       A      B      C      D E
A 1.0000 0.0000 0.0000 0.0000 0
B 0.4530 1.0000 0.0000 0.0000 0
C 0.9046 0.9270 1.0000 0.0000 0
D 0.4490 0.1326 0.4154 1.0000 0
E 0.9575 0.4917 0.7161 0.2938 1

, , C_4

          A      B        C      D E
A 1.0000000 0.0000 0.000000 0.0000 0
B 0.4877241 1.0000 0.000000 0.0000 0
C 0.0593046 0.7625 1.000000 0.0000 0
D 0.0005227 0.1996 0.470509 1.0000 0
E 0.4913541 0.2849 0.005961 0.8901 1


> dim(lxn)
[1] 4 5 5

> dimnames(lxn)
[[1]]
[1] "C_1" "C_2" "C_3" "C_4"

[[2]]
[1] "A" "B" "C" "D" "E"

[[3]]
[1] "A" "B" "C" "D" "E"


> lxd <- ltMatrices(xd, byrow = TRUE, diag = TRUE, names = nm)

> dim(lxd)
[1] 4 5 5

> dimnames(lxd)
[[1]]
[1] "C_1" "C_2" "C_3" "C_4"

[[2]]
[1] "A" "B" "C" "D" "E"

[[3]]
[1] "A" "B" "C" "D" "E"


> lxn <- as.syMatrices(lxn)

> lxn
, , C_1

        A      B       C      D       E
A 1.00000 0.5124 0.05847 0.3945 0.51648
B 0.51237 1.0000 0.90951 0.6612 0.29799
C 0.05847 0.9095 1.00000 0.2335 0.07518
D 0.39449 0.6612 0.23353 1.0000 0.81821
E 0.51648 0.2980 0.07518 0.8182 1.00000

, , C_2

       A      B      C      D      E
A 1.0000 0.8591 0.3744 0.1165 0.1948
B 0.8591 1.0000 0.1023 0.7957 0.4730
C 0.3744 0.1023 1.0000 0.8931 0.2378
D 0.1165 0.7957 0.8931 1.0000 0.2146
E 0.1948 0.4730 0.2378 0.2146 1.0000

, , C_3

       A      B      C      D      E
A 1.0000 0.4530 0.9046 0.4490 0.9575
B 0.4530 1.0000 0.9270 0.1326 0.4917
C 0.9046 0.9270 1.0000 0.4154 0.7161
D 0.4490 0.1326 0.4154 1.0000 0.2938
E 0.9575 0.4917 0.7161 0.2938 1.0000

, , C_4

          A      B        C         D        E
A 1.0000000 0.4877 0.059305 0.0005227 0.491354
B 0.4877241 1.0000 0.762527 0.1995700 0.284943
C 0.0593046 0.7625 1.000000 0.4705089 0.005961
D 0.0005227 0.1996 0.470509 1.0000000 0.890146
E 0.4913541 0.2849 0.005961 0.8901458 1.000000


> a <- as.array(ltMatrices(xn, byrow = TRUE))

> b <- as.array(ltMatrices(ltMatrices(xn, byrow = TRUE), 
+     byrow = FALSE))

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = FALSE))

> b <- as.array(ltMatrices(ltMatrices(xn, byrow = FALSE), 
+     byrow = TRUE))

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE))

> b <- as.array(ltMatrices(ltMatrices(xd, byrow = TRUE, 
+     diag = TRUE), byrow = FALSE))

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE))

> b <- as.array(ltMatrices(ltMatrices(xd, byrow = FALSE, 
+     diag = TRUE), byrow = TRUE))

> chk(a, b)

> i <- colnames(xn)[1:2]

> j <- 2:4

> a <- as.array(ltMatrices(xn, byrow = FALSE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = FALSE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = TRUE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = TRUE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> i <- 1:2

> j <- nm[2:4]

> a <- as.array(ltMatrices(xn, byrow = FALSE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = FALSE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = TRUE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = TRUE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> j <- c(1, 3, 5)

> a <- as.array(ltMatrices(xn, byrow = FALSE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = FALSE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = TRUE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = TRUE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> j <- nm[c(1, 3, 5)]

> a <- as.array(ltMatrices(xn, byrow = FALSE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = FALSE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = TRUE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = TRUE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> j <- -c(1, 3, 5)

> a <- as.array(ltMatrices(xn, byrow = FALSE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = FALSE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = TRUE, names = nm)[i, 
+     j])

> b <- as.array(ltMatrices(xn, byrow = TRUE, names = nm))[j, 
+     j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm)[i, j])

> b <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE, 
+     names = nm))[j, j, i]

> chk(a, b)

> j <- nm[sample(1:J)]

> ltM <- ltMatrices(xn, byrow = FALSE, names = nm)

> try(ltM[i, j])
Error in `[.ltMatrices`(ltM, i, j) : invalid subset argument j

> ltM <- as.syMatrices(ltM)

> a <- as.array(ltM[i, j])

> b <- as.array(ltM)[j, j, i]

> chk(a, b)

> M <- ltMatrices(matrix(1:10, nrow = 10, ncol = 2), 
+     diag = TRUE)

> Lower_tri(M, diag = FALSE)
    [,1] [,2]
2.1    2    2
3.1    3    3
4.1    4    4
3.2    6    6
4.2    7    7
4.3    9    9

> Lower_tri(M, diag = TRUE)
    [,1] [,2]
1.1    1    1
2.1    2    2
3.1    3    3
4.1    4    4
2.2    5    5
3.2    6    6
4.2    7    7
3.3    8    8
4.3    9    9
4.4   10   10

> M <- ltMatrices(matrix(1:6, nrow = 6, ncol = 2), diag = FALSE)

> Lower_tri(M, diag = FALSE)
    [,1] [,2]
2.1    1    1
3.1    2    2
4.1    3    3
3.2    4    4
4.2    5    5
4.3    6    6

> Lower_tri(M, diag = TRUE)
    [,1] [,2]
1.1    1    1
2.1    1    1
3.1    2    2
4.1    3    3
2.2    1    1
3.2    4    4
4.2    5    5
3.3    1    1
4.3    6    6
4.4    1    1

> Lower_tri(invchol2cor(M))
       [,1]    [,2]
2.1 -0.7071 -0.7071
3.1  0.4364  0.4364
4.1 -0.4481 -0.4481
3.2 -0.9258 -0.9258
4.2  0.9189  0.9189
4.3 -0.9974 -0.9974

> all(diagonals(ltMatrices(xn, byrow = TRUE)) == 1)
[1] TRUE

> lxd2 <- lxn

> diagonals(lxd2) <- 1

> chk(as.array(lxd2), as.array(lxn))

> (I5 <- diagonals(5))
, , 1

  1 2 3 4 5
1 1 0 0 0 0
2 0 1 0 0 0
3 0 0 1 0 0
4 0 0 0 1 0
5 0 0 0 0 1


> diagonals(I5) <- 1:5

> I5
, , 1

  1 2 3 4 5
1 1 0 0 0 0
2 0 2 0 0 0
3 0 0 3 0 0
4 0 0 0 4 0
5 0 0 0 0 5


> lxn <- ltMatrices(xn, byrow = TRUE)

> lxd <- ltMatrices(xd, byrow = TRUE, diag = TRUE)

> y <- matrix(runif(N * J), nrow = J)

> a <- Mult(lxn, y)

> A <- as.array(lxn)

> b <- do.call("rbind", lapply(1:ncol(y), function(i) t(A[, 
+     , i] %*% y[, i, drop = FALSE])))

> chk(a, t(b), check.attributes = FALSE)

> a <- Mult(lxd, y)

> A <- as.array(lxd)

> b <- do.call("rbind", lapply(1:ncol(y), function(i) t(A[, 
+     , i] %*% y[, i, drop = FALSE])))

> chk(a, t(b), check.attributes = FALSE)

> chk(Mult(lxn[rep(1, N), ], y), Mult(lxn[1, ], y), 
+     check.attributes = FALSE)

> chk(Mult(lxn, y[, 1]), Mult(lxn, y[, rep(1, N)]))

> i <- sample(1:N)[1]

> M <- t(as.array(lxn)[, , i])

> a <- sapply(1:J, function(j) Mult(lxn[i, ], M[, j, 
+     drop = FALSE]))

> rownames(a) <- colnames(a) <- dimnames(lxn)[[2]]

> b <- as.array(Tcrossprod(lxn[i, ]))[, , 1]

> chk(a, b, check.attributes = FALSE)

> a <- Mult(lxn, y, transpose = TRUE)

> A <- as.array(lxn)

> b <- do.call("rbind", lapply(1:ncol(y), function(i) t(t(A[, 
+     , i]) %*% y[, i, drop = FALSE])))

> chk(a, t(b), check.attributes = FALSE)

> a <- Mult(lxd, y, transpose = TRUE)

> A <- as.array(lxd)

> b <- do.call("rbind", lapply(1:ncol(y), function(i) t(t(A[, 
+     , i]) %*% y[, i, drop = FALSE])))

> chk(a, t(b), check.attributes = FALSE)

> chk(Mult(lxn[rep(1, N), ], y, transpose = TRUE), Mult(lxn[1, 
+     ], y, transpose = TRUE), check.attributes = FALSE)

> chk(Mult(lxn, y[, 1], transpose = TRUE), Mult(lxn, 
+     y[, rep(1, N)], transpose = TRUE))

> J <- 5

> N1 <- 10

> ex <- expression({
+     C <- syMatrices(matrix(runif(N2 * J * (J + c(-1, 1)[DIAG + 
+         1])/2), ncol = N2), diag = DIAG)
+     x <- matrix(ru .... [TRUNCATED] 

> N2 <- N1

> DIAG <- TRUE

> eval(ex)

> N2 <- 1

> DIAG <- TRUE

> eval(ex)

> N2 <- 1

> DIAG <- FALSE

> eval(ex)

> N2 <- N1

> DIAG <- FALSE

> eval(ex)

> A <- as.array(lxn)

> a <- solve(lxn)

> a <- as.array(a)

> b <- array(apply(A, 3, function(x) solve(x), simplify = TRUE), 
+     dim = rev(dim(lxn)))

> chk(a, b, check.attributes = FALSE)

> A <- as.array(lxd)

> a <- as.array(solve(lxd))

> b <- array(apply(A, 3, function(x) solve(x), simplify = TRUE), 
+     dim = rev(dim(lxd)))

> chk(a, b, check.attributes = FALSE)

> chk(solve(lxn, y), Mult(solve(lxn), y))

> chk(solve(lxd, y), Mult(solve(lxd), y))

> chk(solve(lxn[1, ], y), as.array(solve(lxn[1, ]))[, 
+     , 1] %*% y)

> chk(solve(lxn[rep(1, N), ], y), solve(lxn[1, ], y), 
+     check.attributes = FALSE)

> chk(solve(lxn, y[, 1]), solve(lxn, y[, rep(1, N)]))

> chk(solve(lxn[1, ], y, transpose = TRUE), t(as.array(solve(lxn[1, 
+     ]))[, , 1]) %*% y)

> chk(logdet(lxn), colSums(log(diagonals(lxn))))

> chk(logdet(lxd[1, ]), colSums(log(diagonals(lxd[1, 
+     ]))))

> chk(logdet(lxd), colSums(log(diagonals(lxd))))

> lxd2 <- ltMatrices(lxd, byrow = !attr(lxd, "byrow"))

> chk(logdet(lxd2), colSums(log(diagonals(lxd2))))

> a <- as.array(Tcrossprod(lxn))

> b <- array(apply(as.array(lxn), 3, function(x) tcrossprod(x), 
+     simplify = TRUE), dim = rev(dim(lxn)))

> chk(a, b, check.attributes = FALSE)

> d <- Tcrossprod(lxn, diag_only = TRUE)

> chk(d, apply(a, 3, diag))

> chk(d, diagonals(Tcrossprod(lxn)))

> a <- as.array(Tcrossprod(lxd))

> b <- array(apply(as.array(lxd), 3, function(x) tcrossprod(x), 
+     simplify = TRUE), dim = rev(dim(lxd)))

> chk(a, b, check.attributes = FALSE)

> d <- Tcrossprod(lxd, diag_only = TRUE)

> chk(d, apply(a, 3, diag))

> chk(d, diagonals(Tcrossprod(lxd)))

> a <- as.array(Crossprod(lxn))

> b <- array(apply(as.array(lxn), 3, function(x) crossprod(x), 
+     simplify = TRUE), dim = rev(dim(lxn)))

> chk(a, b, check.attributes = FALSE)

> d <- Crossprod(lxn, diag_only = TRUE)

> chk(d, apply(a, 3, diag))

> chk(d, diagonals(Crossprod(lxn)))

> a <- as.array(Crossprod(lxd))

> b <- array(apply(as.array(lxd), 3, function(x) crossprod(x), 
+     simplify = TRUE), dim = rev(dim(lxd)))

> chk(a, b, check.attributes = FALSE)

> d <- Crossprod(lxd, diag_only = TRUE)

> chk(d, apply(a, 3, diag))

> chk(d, diagonals(Crossprod(lxd)))

> Sigma <- Tcrossprod(lxd)

> chk(chol(Sigma), lxd)

> Sigma <- Tcrossprod(lxn)

> chk(as.array(chol(Sigma)), as.array(lxn))

> J <- 10

> d <- TRUE

> L <- diag(J)

> L[lower.tri(L, diag = d)] <- prm <- runif(J * (J + 
+     c(-1, 1)[d + 1])/2)

> C <- solve(L)

> D <- -kronecker(t(C), C)

> S <- diag(J)

> S[lower.tri(S, diag = TRUE)] <- x <- runif(J * (J + 
+     1)/2)

> SD0 <- matrix(c(S) %*% D, ncol = J)

> SD1 <- -crossprod(C, tcrossprod(S, C))

> a <- ltMatrices(C[lower.tri(C, diag = TRUE)], diag = TRUE, 
+     byrow = FALSE)

> b <- ltMatrices(x, diag = TRUE, byrow = FALSE)

> SD2 <- -vectrick(a, b, a)

> SD2a <- -vectrick(a, b)

> chk(SD2, SD2a)

> chk(SD0[lower.tri(SD0, diag = d)], SD1[lower.tri(SD1, 
+     diag = d)])

> chk(SD0[lower.tri(SD0, diag = d)], c(unclass(SD2)))

> S <- t(matrix(as.array(b), byrow = FALSE, nrow = 1))

> SD2 <- -vectrick(a, S, a)

> SD2a <- -vectrick(a, S)

> chk(SD2, SD2a)

> chk(c(SD0), c(SD2))

> N <- 4

> prm <- runif(J * (J - 1)/2)

> C <- ltMatrices(prm)

> S <- matrix(runif(J^2 * N), ncol = N)

> A <- vectrick(C, S, C)

> Cx <- as.array(C)[, , 1]

> B <- apply(S, 2, function(x) t(Cx) %*% matrix(x, ncol = J) %*% 
+     t(Cx))

> chk(A, B)

> A <- vectrick(C, S, C, transpose = c(FALSE, FALSE))

> Cx <- as.array(C)[, , 1]

> B <- apply(S, 2, function(x) Cx %*% matrix(x, ncol = J) %*% 
+     Cx)

> chk(A, B)

> prec2pc <- function(x) {
+     ret <- -cov2cor(x)
+     diag(ret) <- 0
+     ret
+ }

> L <- lxn

> Sigma <- apply(as.array(L), 3, function(x) tcrossprod(solve(x)), 
+     simplify = FALSE)

> Prec <- lapply(Sigma, solve)

> Corr <- lapply(Sigma, cov2cor)

> CP <- lapply(Corr, solve)

> PC <- lapply(Prec, function(x) prec2pc(x))

> chk(unlist(Sigma), c(as.array(invchol2cov(L))), check.attributes = FALSE)

> chk(unlist(Prec), c(as.array(invchol2pre(L))), check.attributes = FALSE)

> chk(unlist(Corr), c(as.array(invchol2cor(L))), check.attributes = FALSE)

> chk(unlist(CP), c(as.array(Crossprod(invcholD(L)))), 
+     check.attributes = FALSE)

> chk(unlist(PC), c(as.array(invchol2pc(L))), check.attributes = FALSE)

> C <- lxn

> Sigma <- apply(as.array(C), 3, function(x) tcrossprod(x), 
+     simplify = FALSE)

> Prec <- lapply(Sigma, solve)

> Corr <- lapply(Sigma, cov2cor)

> CP <- lapply(Corr, solve)

> PC <- lapply(Prec, function(x) prec2pc(x))

> chk(unlist(Sigma), c(as.array(chol2cov(C))), check.attributes = FALSE)

> chk(unlist(Prec), c(as.array(chol2pre(C))), check.attributes = FALSE)

> chk(unlist(Corr), c(as.array(chol2cor(C))), check.attributes = FALSE)

> chk(unlist(CP), c(as.array(Crossprod(solve(Dchol(C))))), 
+     check.attributes = FALSE)

> chk(unlist(PC), c(as.array(chol2pc(C))), check.attributes = FALSE)

> L <- lxd

> Sigma <- apply(as.array(L), 3, function(x) tcrossprod(solve(x)), 
+     simplify = FALSE)

> Prec <- lapply(Sigma, solve)

> Corr <- lapply(Sigma, cov2cor)

> CP <- lapply(Corr, solve)

> PC <- lapply(Prec, function(x) prec2pc(x))

> chk(unlist(Sigma), c(as.array(invchol2cov(L))), check.attributes = FALSE)

> chk(unlist(Prec), c(as.array(invchol2pre(L))), check.attributes = FALSE)

> chk(unlist(Corr), c(as.array(invchol2cor(L))), check.attributes = FALSE)

> chk(unlist(CP), c(as.array(Crossprod(invcholD(L)))), 
+     check.attributes = FALSE)

> chk(unlist(PC), c(as.array(invchol2pc(L))), check.attributes = FALSE)

> C <- lxd

> Sigma <- apply(as.array(C), 3, function(x) tcrossprod(x), 
+     simplify = FALSE)

> Prec <- lapply(Sigma, solve)

> Corr <- lapply(Sigma, cov2cor)

> CP <- lapply(Corr, solve)

> PC <- lapply(Prec, function(x) prec2pc(x))

> chk(unlist(Sigma), c(as.array(chol2cov(C))), check.attributes = FALSE)

> chk(unlist(Prec), c(as.array(chol2pre(C))), check.attributes = FALSE)

> chk(unlist(Corr), c(as.array(chol2cor(C))), check.attributes = FALSE)

> chk(unlist(CP), c(as.array(Crossprod(solve(Dchol(C))))), 
+     check.attributes = FALSE)

> chk(unlist(PC), c(as.array(chol2pc(C))), check.attributes = FALSE)

> L <- as.invchol(lxn)

> J <- dim(L)[2]

> Lp <- aperm(a = L, perm = p <- sample(1:J))

> chk(invchol2cov(L)[, p], invchol2cov(Lp))

> C <- as.chol(lxn)

> J <- dim(C)[2]

> Cp <- aperm(a = C, perm = p <- sample(1:J))

> chk(chol2cov(C)[, p], chol2cov(Cp))

> Sigma <- Tcrossprod(lxd)

> j <- 1:3

> chk(Sigma[, j], Tcrossprod(marg_mvnorm(chol = lxd, 
+     which = j)$chol))

> j <- 2:4

> chk(Sigma[, j], Tcrossprod(marg_mvnorm(chol = lxd, 
+     which = j)$chol))

> Sigma <- Tcrossprod(solve(lxd))

> j <- 1:3

> chk(Sigma[, j], Tcrossprod(solve(marg_mvnorm(invchol = lxd, 
+     which = j)$invchol)))

> j <- 2:4

> chk(Sigma[, j], Tcrossprod(solve(marg_mvnorm(invchol = lxd, 
+     which = j)$invchol)))

> Sigma <- as.array(Tcrossprod(lxd))[, , 1]

> j <- 2:4

> y <- matrix(c(-1, 2, 1), nrow = 3)

> cm <- Sigma[-j, j, drop = FALSE] %*% solve(Sigma[j, 
+     j]) %*% y

> cS <- Sigma[-j, -j] - Sigma[-j, j, drop = FALSE] %*% 
+     solve(Sigma[j, j]) %*% Sigma[j, -j, drop = FALSE]

> cmv <- cond_mvnorm(chol = lxd[1, ], which_given = j, 
+     given = y)

> chk(cm, cmv$mean)

> chk(cS, as.array(Tcrossprod(cmv$chol))[, , 1])

> Sigma <- as.array(Tcrossprod(solve(lxd)))[, , 1]

> j <- 2:4

> y <- matrix(c(-1, 2, 1), nrow = 3)

> cm <- Sigma[-j, j, drop = FALSE] %*% solve(Sigma[j, 
+     j]) %*% y

> cS <- Sigma[-j, -j] - Sigma[-j, j, drop = FALSE] %*% 
+     solve(Sigma[j, j]) %*% Sigma[j, -j, drop = FALSE]

> cmv <- cond_mvnorm(invchol = lxd[1, ], which_given = j, 
+     given = y)

> chk(cm, cmv$mean)

> chk(cS, as.array(Tcrossprod(solve(cmv$invchol)))[, 
+     , 1])

> Sigma <- as.array(Tcrossprod(lxd))[, , 1]

> j <- 1:3

> y <- matrix(c(-1, 2, 1), nrow = 3)

> cm <- Sigma[-j, j, drop = FALSE] %*% solve(Sigma[j, 
+     j]) %*% y

> cS <- Sigma[-j, -j] - Sigma[-j, j, drop = FALSE] %*% 
+     solve(Sigma[j, j]) %*% Sigma[j, -j, drop = FALSE]

> cmv <- cond_mvnorm(chol = lxd[1, ], which_given = j, 
+     given = y)

> chk(c(cm), c(cmv$mean))

> chk(cS, as.array(Tcrossprod(cmv$chol))[, , 1])

> Sigma <- as.array(Tcrossprod(solve(lxd)))[, , 1]

> j <- 1:3

> y <- matrix(c(-1, 2, 1), nrow = 3)

> cm <- Sigma[-j, j, drop = FALSE] %*% solve(Sigma[j, 
+     j]) %*% y

> cS <- Sigma[-j, -j] - Sigma[-j, j, drop = FALSE] %*% 
+     solve(Sigma[j, j]) %*% Sigma[j, -j, drop = FALSE]

> cmv <- cond_mvnorm(invchol = lxd[1, ], which_given = j, 
+     given = y)

> chk(c(cm), c(cmv$mean))

> chk(cS, as.array(Tcrossprod(solve(cmv$invchol)))[, 
+     , 1])

> N <- 1000

> J <- 50

> lt <- ltMatrices(matrix(runif(N * J * (J + 1)/2) + 
+     1, ncol = N), diag = TRUE, byrow = FALSE)

> Z <- matrix(rnorm(N * J), ncol = N)

> Y <- solve(lt, Z)

> ll1 <- sum(dnorm(Mult(lt, Y), log = TRUE)) + sum(log(diagonals(lt)))

> S <- as.array(Tcrossprod(solve(lt)))

> ll2 <- sum(sapply(1:N, function(i) dmvnorm(x = Y[, 
+     i], sigma = S[, , i], log = TRUE)))

> chk(ll1, ll2)

> ll3 <- ldmvnorm(obs = Y, invchol = lt)

> chk(ll1, ll3)

> (j <- 1:5 * 10)
[1] 10 20 30 40 50

> md <- marg_mvnorm(invchol = lt, which = j)

> cd <- cond_mvnorm(invchol = lt, which_given = j, given = Y[j, 
+     ])

> ll3 <- sum(dnorm(Mult(md$invchol, Y[j, ]), log = TRUE)) + 
+     sum(log(diagonals(md$invchol))) + sum(dnorm(Mult(cd$invchol, 
+     Y[-j, ] - cd$me .... [TRUNCATED] 

> chk(ll1, ll3)

> set.seed(270312)

> lpmvnormR <- function(lower, upper, mean = 0, center = NULL, 
+     chol, logLik = TRUE, ...) {
+     if (!is.matrix(lower)) 
+         lower <- mat .... [TRUNCATED] 

> J <- 5

> N <- 10

> x <- matrix(runif(N * J * (J + 1)/2), ncol = N)

> lx <- ltMatrices(x, byrow = TRUE, diag = TRUE)

> a <- matrix(runif(N * J), nrow = J) - 2

> a[sample(J * N)[1:2]] <- -Inf

> b <- a + 2 + matrix(runif(N * J), nrow = J)

> b[sample(J * N)[1:2]] <- Inf

> (phat <- c(lpmvnormR(a, b, chol = lx, logLik = FALSE)))
 [1] 0.2369 0.2337 0.2842 0.3915 0.4662 0.0000 0.5901 0.4619 0.4873 0.0000

> phat
 [1] 0.2369 0.2337 0.2842 0.3915 0.4662 0.0000 0.5901 0.4619 0.4873 0.0000

> exp(lpmvnorm(a, b, chol = lx, M = 25000, logLik = FALSE, 
+     fast = TRUE))
 [1] 2.367e-01 2.341e-01 2.835e-01 3.939e-01 4.658e-01 8.882e-21 5.911e-01
 [8] 4.598e-01 4.879e-01 8.882e-21

> exp(lpmvnorm(a, b, chol = lx, M = 25000, logLik = FALSE, 
+     fast = FALSE))
 [1] 2.377e-01 2.372e-01 2.832e-01 3.875e-01 4.660e-01 8.882e-21 5.895e-01
 [8] 4.624e-01 4.871e-01 8.882e-21

> M <- 10000

> if (require("qrng", quietly = TRUE)) {
+     W <- t(ghalton(M, d = J - 1))
+ } else {
+     W <- matrix(runif(M * (J - 1)), nrow = J - 1)
+ }

> pGB <- lpmvnormR(a, b, chol = lx, logLik = FALSE, 
+     algorithm = GenzBretz(maxpts = M, abseps = 0, releps = 0))

> pGqf <- exp(lpmvnorm(a, b, chol = lx, w = W, M = M, 
+     logLik = FALSE, fast = TRUE))

> pGf <- exp(lpmvnorm(a, b, chol = lx, w = NULL, M = M, 
+     logLik = FALSE, fast = TRUE))

> pGqs <- exp(lpmvnorm(a, b, chol = lx, w = W, M = M, 
+     logLik = FALSE, fast = FALSE))

> pGs <- exp(lpmvnorm(a, b, chol = lx, w = NULL, M = M, 
+     logLik = FALSE, fast = FALSE))

> cbind(pGB, pGqf, pGf, pGqs, pGs)
         pGB      pGqf       pGf      pGqs       pGs
 [1,] 0.2369 2.369e-01 2.345e-01 2.369e-01 2.360e-01
 [2,] 0.2342 2.340e-01 2.319e-01 2.340e-01 2.347e-01
 [3,] 0.2841 2.841e-01 2.851e-01 2.841e-01 2.870e-01
 [4,] 0.3918 3.921e-01 3.932e-01 3.921e-01 3.904e-01
 [5,] 0.4671 4.668e-01 4.679e-01 4.668e-01 4.691e-01
 [6,] 0.0000 2.220e-20 2.220e-20 2.220e-20 2.220e-20
 [7,] 0.5902 5.902e-01 5.908e-01 5.902e-01 5.929e-01
 [8,] 0.4613 4.619e-01 4.612e-01 4.619e-01 4.630e-01
 [9,] 0.4872 4.870e-01 4.863e-01 4.870e-01 4.821e-01
[10,] 0.0000 2.220e-20 2.220e-20 2.220e-20 2.220e-20

> pGB <- lpmvnormR(a[1, , drop = FALSE], b[1, , drop = FALSE], 
+     chol = lx[, 1], logLik = FALSE, algorithm = GenzBretz(maxpts = M, 
+         abs .... [TRUNCATED] 

> pGq <- exp(lpmvnorm(a[1, , drop = FALSE], b[1, , drop = FALSE], 
+     chol = lx[, 1], logLik = FALSE))

> ptr <- pnorm(b[1, ]/c(unclass(lx[, 1]))) - pnorm(a[1, 
+     ]/c(unclass(lx[, 1])))

> cbind(c(ptr), pGB, pGq)
                pGB    pGq
 [1,] 1.0000 1.0000 1.0000
 [2,] 0.6109 0.6109 0.6109
 [3,] 0.9076 0.9076 0.9076
 [4,] 0.8980 0.8980 0.8980
 [5,] 0.9589 0.9589 0.9589
 [6,] 0.7863 0.7863 0.7863
 [7,] 0.9983 0.9983 0.9983
 [8,] 0.8745 0.8745 0.8745
 [9,] 0.9386 0.9386 0.9386
[10,] 0.9120 0.9120 0.9120

> J <- 5

> N <- 4

> S <- crossprod(matrix(runif(J^2), nrow = J))

> prm <- t(chol(S))[lower.tri(S, diag = TRUE)]

> mC <- ltMatrices(matrix(prm, ncol = 1), diag = TRUE)

> a <- matrix(runif(N * J), nrow = J) - 2

> b <- a + 4

> a[2, ] <- -Inf

> b[3, ] <- Inf

> M <- 10000

> W <- matrix(runif(M * (J - 1)), ncol = M)

> lli <- c(lpmvnorm(a, b, chol = mC, w = W, M = M, logLik = FALSE))

> fC <- function(prm) {
+     C <- ltMatrices(matrix(prm, ncol = 1), diag = TRUE)
+     lpmvnorm(a, b, chol = C, w = W, M = M)
+ }

> sC <- slpmvnorm(a, b, chol = mC, w = W, M = M)

> chk(lli, sC$logLik)

> if (require("numDeriv", quietly = TRUE)) chk(grad(fC, 
+     unclass(mC)), rowSums(unclass(sC$chol)), check.attributes = FALSE)

> mL <- solve(mC)

> lliL <- c(lpmvnorm(a, b, invchol = mL, w = W, M = M, 
+     logLik = FALSE))

> chk(lli, lliL)

> fL <- function(prm) {
+     L <- ltMatrices(matrix(prm, ncol = 1), diag = TRUE)
+     lpmvnorm(a, b, invchol = L, w = W, M = M)
+ }

> sL <- slpmvnorm(a, b, invchol = mL, w = W, M = M)

> chk(lliL, sL$logLik)

> if (require("numDeriv", quietly = TRUE)) chk(grad(fL, 
+     unclass(mL)), rowSums(unclass(sL$invchol)), check.attributes = FALSE)

> ptr <- pnorm(b[1, ]/c(unclass(mC[, 1]))) - pnorm(a[1, 
+     ]/c(unclass(mC[, 1])))

> log(ptr)
[1] -0.01166 -0.08617 -0.01240 -0.03105

> lpmvnorm(a[1, , drop = FALSE], b[1, , drop = FALSE], 
+     chol = mC[, 1], logLik = FALSE)
[1] -0.01166 -0.08617 -0.01240 -0.03105

> lapply(slpmvnorm(a[1, , drop = FALSE], b[1, , drop = FALSE], 
+     chol = mC[, 1], logLik = TRUE), unclass)
$logLik
[1] -0.01166 -0.08617 -0.01240 -0.03105

$mean
     [,1]  [,2]    [,3]    [,4]
1 0.02222 0.214 0.02642 0.08861

$lower
      [,1]    [,2]     [,3]     [,4]
1 -0.03222 -0.2145 -0.03536 -0.09096

$upper
      [,1]      [,2]     [,3]     [,4]
1 0.009995 0.0004369 0.008944 0.002351

$chol
       [,1]    [,2]    [,3]    [,4]
1.1 -0.1041 -0.2994 -0.1076 -0.1787
attr(,"J")
[1] 1
attr(,"diag")
[1] TRUE
attr(,"byrow")
[1] FALSE
attr(,"rcnames")
[1] "1"


> sd1 <- c(unclass(mC[, 1]))

> (dnorm(b[1, ]/sd1) * b[1, ] - dnorm(a[1, ]/sd1) * 
+     a[1, ]) * (-1)/sd1^2/ptr
[1] -0.1041 -0.2994 -0.1076 -0.1787

> set.seed(110515)

> J <- 4

> R <- diag(J)

> R[1, 2] <- R[2, 1] <- 0.25

> R[1, 3] <- R[3, 1] <- 0.5

> R[2, 4] <- R[4, 2] <- 0.75

> Sigma <- diag(sqrt(1:J/2)) %*% R %*% diag(sqrt(1:J/2))

> C <- t(chol(Sigma))

> prm <- C[lower.tri(C, diag = TRUE)]

> lt <- ltMatrices(matrix(prm, ncol = 1), diag = TRUE, 
+     byrow = FALSE)

> BYROW <- FALSE

> lt <- ltMatrices(lt, byrow = BYROW)

> chk(C, as.array(lt)[, , 1], check.attributes = FALSE)

> chk(Sigma, as.array(Tcrossprod(lt))[, , 1], check.attributes = FALSE)

> N <- 100

> Z <- matrix(rnorm(N * J), nrow = J)

> Y <- Mult(lt, Z) + (mn <- 1:J)

> rowMeans(Y)
     1      2      3      4 
0.9685 2.1269 2.9634 3.9826 

> (Shat <- var(t(Y)) * (N - 1)/N)
        1       2       3       4
1 0.46656 0.18104 0.34222 0.01609
2 0.18104 0.94385 0.08992 0.84310
3 0.34222 0.08992 1.36055 0.08104
4 0.01609 0.84310 0.08104 1.63302

> Yc <- Y - rowMeans(Y)

> ll <- function(parm) {
+     C <- ltMatrices(parm, diag = TRUE, byrow = BYROW)
+     -ldmvnorm(obs = Yc, chol = C)
+ }

> sc <- function(parm) {
+     C <- ltMatrices(parm, diag = TRUE, byrow = BYROW)
+     -rowSums(unclass(sldmvnorm(obs = Yc, chol = C)$chol))
+ }

> llim <- rep(-Inf, J * (J + 1)/2)

> llim[which(rownames(unclass(lt)) %in% paste(1:J, 1:J, 
+     sep = "."))] <- 1e-04

> if (BYROW) {
+     cML <- chol(Shat)[upper.tri(Shat, diag = TRUE)]
+ } else {
+     cML <- t(chol(Shat))[lower.tri(Shat, diag = TRUE)]
+ }

> ll(cML)
[1] 517.9

> start <- runif(length(cML))

> if (require("numDeriv", quietly = TRUE)) chk(grad(ll, 
+     start), sc(start), check.attributes = FALSE)

> op <- optim(start, fn = ll, gr = sc, method = "L-BFGS-B", 
+     lower = llim, control = list(trace = FALSE))

> ltMatrices(op$par, diag = TRUE, byrow = BYROW)
, , 1

        1        2      3      4
1 0.68306  0.00000 0.0000 0.0000
2 0.26505  0.93465 0.0000 0.0000
3 0.50102 -0.04587 1.0523 0.0000
4 0.02356  0.89535 0.1048 0.9054


> ll(op$par)
[1] 517.9

> t(chol(Shat))
        1        2      3      4
1 0.68305  0.00000 0.0000 0.0000
2 0.26505  0.93467 0.0000 0.0000
3 0.50102 -0.04587 1.0523 0.0000
4 0.02356  0.89535 0.1048 0.9054

> ll(cML)
[1] 517.9

> lt
, , 1

       1       2      3     4
1 0.7071  0.0000 0.0000 0.000
2 0.2500  0.9682 0.0000 0.000
3 0.6124 -0.1581 1.0488 0.000
4 0.0000  1.0954 0.1651 0.879


> prb <- 1:9/10

> sds <- sqrt(diag(Sigma))

> ct <- sapply(1:J, function(j) qnorm(prb, mean = mn[j], 
+     sd = sds[j]))

> lwr <- upr <- Y

> for (j in 1:J) {
+     f <- cut(Y[j, ], breaks = c(-Inf, ct[, j], Inf))
+     lwr[j, ] <- c(-Inf, ct[, j])[f]
+     upr[j, ] <- c(ct[, j], Inf)[f]
+ .... [TRUNCATED] 

> M <- c(1000, 1105, 1221, 1349, 1491, 1648, 1822, 2013, 
+     2225, 2459, 2718, 3004, 3320, 3669, 4055, 4481, 4953, 5473, 
+     6049, 6685, 7389, 8 .... [TRUNCATED] 

> lGB <- matrix(c(0.054, -880.492612, 0.054, -880.492426, 
+     0.054, -880.492996, 0.054, -880.492629, 0.054, -880.490231, 
+     0.055, -880.492784 .... [TRUNCATED] 

> rownames(lGB) <- c("user.self", "ll")

> lH <- matrix(c(0.023, -880.480296, 0.027, -880.496166, 
+     0.029, -880.488683, 0.032, -880.496171, 0.035, -880.485597, 
+     0.039, -880.491333, .... [TRUNCATED] 

> rownames(lH) <- c("user.self", "ll")

> lHf <- matrix(c(0.018, -880.487067, 0.019, -880.488639, 
+     0.022, -880.488569, 0.024, -880.49393, 0.026, -880.486029, 
+     0.029, -880.491563, .... [TRUNCATED] 

> rownames(lHf) <- c("user.self", "ll")

> layout(matrix(1:2, nrow = 1))

> plot(M, lGB["ll", ], ylim = range(c(lGB["ll", ], lH["ll", 
+     ], lHf["ll", ])), ylab = "Log-likelihood")

> points(M, lH["ll", ], pch = 4)

> points(M, lHf["ll", ], pch = 5)

> plot(M, lGB["user.self", ], ylim = c(0, max(lGB["user.self", 
+     ])), ylab = "Time (in sec)")

> points(M, lH["user.self", ], pch = 4)

> points(M, lHf["user.self", ], pch = 5)

> legend("bottomright", legend = c("pmvnorm", "lpmvnorm", 
+     "lpmvnorm(fast)"), pch = c(1, 4, 5), bty = "n")

> M <- 500

> if (require("qrng", quietly = TRUE)) {
+     W <- t(ghalton(M, d = J - 1))
+ } else {
+     W <- matrix(runif(M * (J - 1)), nrow = J - 1)
+ }

> ll <- function(parm, J) {
+     m <- parm[1:J]
+     parm <- parm[-(1:J)]
+     C <- matrix(c(parm), ncol = 1)
+     C <- ltMatrices(C, diag = TRUE, .... [TRUNCATED] 

> prm <- c(mn, unclass(lt))

> ll(prm, J = J)
[1] 880.5

> round(lpmvnormR(lwr, upr, mean = mn, chol = lt, algorithm = GenzBretz(maxpts = M, 
+     abseps = 0, releps = 0)), 3)
[1] -880.5

> (llprm <- lpmvnorm(lwr, upr, mean = mn, chol = lt, 
+     w = W, M = M))
[1] -880.5

> chk(llprm, sum(lpmvnorm(lwr, upr, mean = mn, chol = lt, 
+     w = W, M = M, logLik = FALSE)))

> sc <- function(parm, J) {
+     m <- parm[1:J]
+     parm <- parm[-(1:J)]
+     C <- matrix(c(parm), ncol = 1)
+     C <- ltMatrices(C, diag = TRUE, .... [TRUNCATED] 

> if (require("numDeriv", quietly = TRUE)) chk(grad(ll, 
+     prm, J = J), sc(prm, J = J), check.attributes = FALSE)

> llim <- rep(-Inf, J + J * (J + 1)/2)

> llim[J + which(rownames(unclass(lt)) %in% paste(1:J, 
+     1:J, sep = "."))] <- 1e-04

> if (BYROW) {
+     start <- c(rowMeans(Y), chol(Shat)[upper.tri(Shat, diag = TRUE)])
+ } else {
+     start <- c(rowMeans(Y), t(chol(Shat))[lower.tr .... [TRUNCATED] 

> ll(start, J = J)
[1] 875.4

> op <- optim(start, fn = ll, gr = sc, J = J, method = "L-BFGS-B", 
+     lower = llim, control = list(trace = FALSE))

> op$value
[1] 874.2

> ll(prm, J = J)
[1] 880.5

> (C <- ltMatrices(matrix(op$par[-(1:J)], ncol = 1), 
+     diag = TRUE, byrow = BYROW))
, , 1

        1        2       3      4
1 0.67050  0.00000 0.00000 0.0000
2 0.26764  1.02232 0.00000 0.0000
3 0.54268 -0.05007 1.11348 0.0000
4 0.05223  0.98430 0.08473 0.9614


> lt
, , 1

       1       2      3     4
1 0.7071  0.0000 0.0000 0.000
2 0.2500  0.9682 0.0000 0.000
3 0.6124 -0.1581 1.0488 0.000
4 0.0000  1.0954 0.1651 0.879


> op$par[1:J]
    1     2     3     4 
0.967 2.128 2.945 3.989 

> mn
[1] 1 2 3 4

> round(Tcrossprod(lt), 4)
, , 1

       1      2     3     4
1 0.5000 0.1768 0.433 0.000
2 0.1768 1.0000 0.000 1.061
3 0.4330 0.0000 1.500 0.000
4 0.0000 1.0607 0.000 2.000


> Tcrossprod(C)
, , 1

        1       2       3       4
1 0.44956 0.17945 0.36386 0.03502
2 0.17945 1.11677 0.09406 1.02025
3 0.36386 0.09406 1.53684 0.07341
4 0.03502 1.02025 0.07341 1.90298


> Shat
        1       2       3       4
1 0.46656 0.18104 0.34222 0.01609
2 0.18104 0.94385 0.08992 0.84310
3 0.34222 0.08992 1.36055 0.08104
4 0.01609 0.84310 0.08104 1.63302

> c(cond_mvnorm(chol = C, which_given = 2:J, given = diag(J - 
+     1))$mean)
[1]  0.2602  0.2270 -0.1299

> c(cond_mvnorm(chol = aperm(as.chol(C), perm = c(2:J, 
+     1)), which_given = 1:(J - 1), given = diag(J - 1))$mean)
[1]  0.2602  0.2270 -0.1299

> x <- as.array(chol2pre(aperm(as.chol(C), perm = c(2:J, 
+     1))))[J, , 1]

> c(-x[-J]/x[J])
      2       3       4 
 0.2602  0.2270 -0.1299 

> dY <- as.data.frame(t(Y))

> colnames(dY) <- paste0("Y", 1:J)

> coef(m1 <- lm(Y1 ~ ., data = dY))[-1]
     Y2      Y3      Y4 
 0.3169  0.2405 -0.1657 

> H <- optim(op$par, fn = ll, gr = sc, J = J, method = "L-BFGS-B", 
+     lower = llim, hessian = TRUE, control = list(trace = FALSE))$hessian

> L <- try(t(chol(H)))

> if (inherits(L, "try-error")) L <- t(chol(H + 1e-04 * 
+     diag(nrow(H))))

> L <- ltMatrices(L[lower.tri(L, diag = TRUE)], diag = TRUE)

> Nsim <- 50000

> Z <- matrix(rnorm(Nsim * nrow(H)), ncol = Nsim)

> rC <- solve(L, Z)[-(1:J), ] + op$par[-(1:J)]

> c(sqrt(rowMeans((rC - rowMeans(rC))^2)))
      5       6       7       8       9      10      11      12      13      14 
0.05130 0.07990 0.12446 0.16090 0.07609 0.11567 0.14020 0.09622 0.10415 0.08279 

> c(sqrt(diagonals(Crossprod(solve(L)))))
 [1] 0.06826 0.10816 0.12670 0.14074 0.05498 0.10839 0.12442 0.14312 0.08813
[10] 0.11638 0.13340 0.09587 0.10451 0.08154

> rC <- ltMatrices(rC, diag = TRUE)

> rbeta <- cond_mvnorm(chol = rC, which_given = 2:J, 
+     given = diag(J - 1))$mean

> sqrt(rowMeans((rbeta - rowMeans(rbeta))^2))
[1] 0.08793 0.04869 0.07752

> sqrt(diag(vcov(m1)))[-1]
     Y2      Y3      Y4 
0.08230 0.05039 0.06246 

> ic <- 1:2

> ll_cd <- function(parm, J) {
+     m <- parm[1:J]
+     parm <- parm[-(1:J)]
+     C <- matrix(c(parm), ncol = 1)
+     C <- ltMatrices(C, diag = TR .... [TRUNCATED] 

> sc_cd <- function(parm, J) {
+     m <- parm[1:J]
+     parm <- parm[-(1:J)]
+     C <- matrix(c(parm), ncol = 1)
+     C <- ltMatrices(C, diag = TR .... [TRUNCATED] 

> if (require("numDeriv", quietly = TRUE)) chk(grad(ll_cd, 
+     start, J = J), sc_cd(start, J = J), check.attributes = FALSE, 
+     tolerance = 1e- .... [TRUNCATED] 

> op <- optim(start, fn = ll_cd, gr = sc_cd, J = J, 
+     method = "L-BFGS-B", lower = llim, control = list(trace = FALSE))

> ltMatrices(matrix(op$par[-(1:J)], ncol = 1), diag = TRUE, 
+     byrow = BYROW)
, , 1

        1        2       3      4
1 0.68303  0.00000 0.00000 0.0000
2 0.26504  0.93467 0.00000 0.0000
3 0.53509 -0.05736 1.11261 0.0000
4 0.06749  0.95887 0.07775 0.9669


> lt
, , 1

       1       2      3     4
1 0.7071  0.0000 0.0000 0.000
2 0.2500  0.9682 0.0000 0.000
3 0.6124 -0.1581 1.0488 0.000
4 0.0000  1.0954 0.1651 0.879


> op$par[1:J]
     1      2      3      4 
0.9685 2.1269 2.9441 3.9898 

> mn
[1] 1 2 3 4

> perm <- c((1:J)[-ic], ic)

> ll_ap <- function(parm, J) {
+     m <- parm[1:J]
+     parm <- parm[-(1:J)]
+     C <- matrix(c(parm), ncol = 1)
+     C <- ltMatrices(C, diag = TR .... [TRUNCATED] 

> sc_ap <- function(parm, J) {
+     m <- parm[1:J]
+     parm <- parm[-(1:J)]
+     C <- matrix(c(parm), ncol = 1)
+     C <- ltMatrices(C, diag = TR .... [TRUNCATED] 

> if (require("numDeriv", quietly = TRUE)) chk(grad(ll_ap, 
+     start, J = J), sc_ap(start, J = J), check.attributes = FALSE, 
+     tolerance = 1e- .... [TRUNCATED] 

> op <- optim(start, fn = ll_ap, gr = sc_ap, J = J, 
+     method = "L-BFGS-B", lower = llim, control = list(trace = FALSE))

> ltMatrices(matrix(op$par[-(1:J)], ncol = 1), diag = TRUE, 
+     byrow = BYROW)
, , 1

        1       2      3      4
1 1.23596 0.00000 0.0000 0.0000
2 0.05465 1.36452 0.0000 0.0000
3 0.29576 0.02194 0.6153 0.0000
4 0.07133 0.66705 0.2361 0.6619


> round(as.array(aperm(as.chol(lt), perm = perm)), 4)
, , 1

       3     4      1      2
3 1.2247 0.000 0.0000 0.0000
4 0.0000 1.414 0.0000 0.0000
1 0.3536 0.000 0.6124 0.0000
2 0.0000 0.750 0.2887 0.5951


> C <- ltMatrices(runif(10))

> all.equal(as.array(chol2cov(standardize(chol = C))), 
+     as.array(chol2cor(standardize(chol = C))))
[1] TRUE

> L <- solve(C)

> all.equal(as.array(invchol2cov(standardize(invchol = L))), 
+     as.array(invchol2cor(standardize(invchol = L))))
[1] TRUE

> data("iris", package = "datasets")

> J <- 4

> Z <- t(qnorm(do.call("cbind", lapply(iris[1:J], rank))/(nrow(iris) + 
+     1)))

> (CR <- cor(t(Z)))
             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length      1.00000    -0.09887       0.8695      0.7819
Sepal.Width      -0.09887     1.00000      -0.2710     -0.2414
Petal.Length      0.86952    -0.27099       1.0000      0.8714
Petal.Width       0.78191    -0.24142       0.8714      1.0000

> ll <- function(parm) {
+     C <- ltMatrices(parm)
+     Cs <- standardize(C)
+     -ldmvnorm(obs = Z, chol = Cs)
+ }

> sc <- function(parm) {
+     C <- ltMatrices(parm)
+     Cs <- standardize(C)
+     -rowSums(Lower_tri(destandardize(chol = C, score_schol = sldmvno .... [TRUNCATED] 

> start <- t(chol(CR))

> start <- start[lower.tri(start)]

> if (require("numDeriv", quietly = TRUE)) chk(grad(ll, 
+     start), sc(start), check.attributes = FALSE)

> op <- optim(start, fn = ll, gr = sc, method = "BFGS", 
+     control = list(trace = FALSE), hessian = TRUE)

> op$value
[1] 602.5

> S_ML <- chol2cov(standardize(ltMatrices(op$par)))

> lwr <- do.call("cbind", lapply(iris[1:J], rank, ties.method = "min")) - 
+     1

> upr <- do.call("cbind", lapply(iris[1:J], rank, ties.method = "max"))

> lwr <- t(qnorm(lwr/nrow(iris)))

> upr <- t(qnorm(upr/nrow(iris)))

> M <- 500

> if (require("qrng", quietly = TRUE)) {
+     W <- t(ghalton(M, d = J - 1))
+ } else {
+     W <- matrix(runif(M * (J - 1)), nrow = J - 1)
+ }

> ll <- function(parm) {
+     C <- ltMatrices(parm)
+     Cs <- standardize(C)
+     -lpmvnorm(lower = lwr, upper = upr, chol = Cs, M = M, w = W)
+ }

> sc <- function(parm) {
+     C <- ltMatrices(parm)
+     Cs <- standardize(C)
+     -rowSums(Lower_tri(destandardize(chol = C, score_schol = slpmvno .... [TRUNCATED] 

> if (require("numDeriv", quietly = TRUE)) chk(grad(ll, 
+     start), sc(start), check.attributes = FALSE)

> op2 <- optim(start, fn = ll, gr = sc, method = "BFGS", 
+     control = list(trace = FALSE), hessian = TRUE)

> S_NPML <- chol2cov(standardize(ltMatrices(op2$par)))

> S_ML
, , 1

        1       2       3       4
1  1.0000 -0.1139  0.8768  0.7962
2 -0.1139  1.0000 -0.2856 -0.2575
3  0.8768 -0.2856  1.0000  0.8817
4  0.7962 -0.2575  0.8817  1.0000


> S_NPML
, , 1

         1        2       3       4
1  1.00000 -0.09786  0.8735  0.7833
2 -0.09786  1.00000 -0.2726 -0.2482
3  0.87346 -0.27260  1.0000  0.8849
4  0.78328 -0.24822  0.8849  1.0000


> sd_ML <- ltMatrices(sqrt(diag(solve(op$hessian))))

> diagonals(sd_ML) <- 0

> sd_NPML <- try(ltMatrices(sqrt(diag(solve(op2$hessian)))))

> if (!inherits(sd_NPML, "try-error")) {
+     diagonals(sd_NPML) <- 0
+     print(sd_ML)
+     print(sd_NPML)
+ }
, , 1

        1       2     3 4
1 0.00000 0.00000 0.000 0
2 0.08122 0.00000 0.000 0
3 0.13679 0.08762 0.000 0
4 0.12621 0.10787 0.101 0

, , 1

        1       2      3 4
1 0.00000 0.00000 0.0000 0
2 0.07731 0.00000 0.0000 0
3 0.14000 0.08695 0.0000 0
4 0.13691 0.11038 0.1161 0


> data("iris", package = "datasets")

> vars <- names(iris)[-5]

> N <- nrow(iris)

> m <- colMeans(iris[, vars])

> V <- var(iris[, vars]) * (N - 1)/N

> iris_mvn <- mvnorm(mean = m, chol = t(chol(V)))

> iris_var <- simulate(iris_mvn, nsim = nrow(iris))

> j <- 3:4

> margDist(iris_mvn, which = vars[j])
$scale
, , 1

             Petal.Length Petal.Width
Petal.Length       1.7594      0.0000
Petal.Width        0.7315      0.2051


$mean
              [,1]
Petal.Length 3.758
Petal.Width  1.199

attr(,"class")
[1] "mvnorm"

> gm <- t(iris[, vars[-(j)]])

> iris_cmvn <- condDist(iris_mvn, which_given = vars[j], 
+     given = gm)

> logLik(object = iris_cmvn, obs = t(iris[, vars[-j]]))
[1] -4782

> logLik(object = iris_cmvn, obs = t(iris[, rev(vars[-j])]))
[1] -4782

> J <- length(vars)

> obs <- t(iris[, vars])

> lower <- upper <- NULL

> ll <- function(parm) {
+     C <- ltMatrices(parm[-(1:J)], diag = TRUE, names = vars)
+     x <- mvnorm(mean = parm[1:J], chol = C)
+     -logLik(ob .... [TRUNCATED] 

> sc <- function(parm) {
+     C <- ltMatrices(parm[-(1:J)], diag = TRUE, names = vars)
+     x <- mvnorm(mean = parm[1:J], chol = C)
+     ret <- lLg .... [TRUNCATED] 

> start <- c(c(iris_mvn$mean), Lower_tri(iris_mvn$scale, 
+     diag = TRUE))

> max(abs(sc(start))) < sqrt(.Machine$double.eps)
[1] TRUE

> op <- optim(start, fn = ll, gr = sc, method = "L-BFGS-B", 
+     lower = llim, control = list(trace = FALSE))

> Chat <- ltMatrices(op$par[-(1:J)], diag = TRUE, names = vars)

> ML <- mvnorm(mean = op$par[1:J], chol = Chat)

> chol2cov(ML$scale)
, , 1

             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length      0.68112    -0.04215       1.2658      0.5128
Sepal.Width      -0.04215     0.18871      -0.3275     -0.1208
Petal.Length      1.26582    -0.32746       3.0955      1.2870
Petal.Width       0.51283    -0.12083       1.2870      0.5771


> V
             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length      0.68112    -0.04215       1.2658      0.5128
Sepal.Width      -0.04215     0.18871      -0.3275     -0.1208
Petal.Length      1.26582    -0.32746       3.0955      1.2870
Petal.Width       0.51283    -0.12083       1.2870      0.5771

> ML$mean[, , drop = TRUE]
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
       5.843        3.057        3.758        1.199 

> m
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
       5.843        3.057        3.758        1.199 

> v1 <- vars[1]

> q1 <- quantile(iris[[v1]], probs = 1:4/5)

> head(f1 <- cut(iris[[v1]], breaks = c(-Inf, q1, Inf)))
[1] (5,5.6]  (-Inf,5] (-Inf,5] (-Inf,5] (-Inf,5] (5,5.6] 
Levels: (-Inf,5] (5,5.6] (5.6,6.1] (6.1,6.52] (6.52, Inf]

> lower <- matrix(c(-Inf, q1)[f1], nrow = 1)

> upper <- matrix(c(q1, Inf)[f1], nrow = 1)

> rownames(lower) <- rownames(upper) <- v1

> obs <- obs[!rownames(obs) %in% v1, , drop = FALSE]

> if (require("numDeriv", quietly = TRUE)) chk(grad(ll, 
+     start), sc(start), check.attributes = FALSE)

> opi <- optim(start, fn = ll, gr = sc, method = "L-BFGS-B", 
+     lower = llim, control = list(trace = FALSE))

> Chati <- ltMatrices(opi$par[-(1:J)], diag = TRUE, 
+     names = vars)

> MLi <- mvnorm(mean = opi$par[1:J], chol = Chati)

> op$value
[1] 379.9

> opi$value
[1] 472.2

> chol2cov(MLi$scale)
, , 1

             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length      0.72585    -0.02555       1.2710      0.5221
Sepal.Width      -0.02555     0.18871      -0.3274     -0.1208
Petal.Length      1.27103    -0.32742       3.0950      1.2867
Petal.Width       0.52211    -0.12081       1.2867      0.5770


> chol2cov(ML$scale)
, , 1

             Sepal.Length Sepal.Width Petal.Length Petal.Width
Sepal.Length      0.68112    -0.04215       1.2658      0.5128
Sepal.Width      -0.04215     0.18871      -0.3275     -0.1208
Petal.Length      1.26582    -0.32746       3.0955      1.2870
Petal.Width       0.51283    -0.12083       1.2870      0.5771


> MLi$mean[, , drop = TRUE]
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
       5.760        3.057        3.758        1.199 

> ML$mean[, , drop = TRUE]
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
       5.843        3.057        3.758        1.199 

> N <- 3

> J <- 4

> L <- ltMatrices(runif(J * (J + 1)/2), diag = TRUE, 
+     names = LETTERS[1:J])

> Z <- matrix(rnorm(J * N), nrow = J)

> Y <- solve(L, Z)

> lwrA <- matrix(-1, nrow = 1, ncol = N)

> uprA <- matrix(1, nrow = 1, ncol = N)

> rownames(lwrA) <- rownames(uprA) <- "A"

> lwrB <- matrix(-Inf, nrow = 1, ncol = N)

> uprB <- matrix(Inf, nrow = 1, ncol = N)

> rownames(lwrB) <- rownames(uprB) <- "B"

> lwr <- rbind(lwrA, lwrB)

> upr <- rbind(uprA, uprB)

> obs <- Y[rev(LETTERS[3:J]), ]

> w <- matrix(runif(1000), nrow = 1)

> lABCD <- logLik(mvnorm(invchol = L), obs = obs, lower = lwr, 
+     upper = upr, w = w)

> sABCD <- lLgrad(mvnorm(invchol = L), obs = obs, lower = lwr, 
+     upper = upr, w = w)

> lACD <- logLik(mvnorm(invchol = L), obs = obs, lower = lwrA, 
+     upper = uprA)

> sACD <- lLgrad(mvnorm(invchol = L), obs = obs, lower = lwrA, 
+     upper = uprA)

> chk(lABCD, lACD)

> nm <- names(sABCD)

> nm <- nm[!nm %in% c("lower", "upper")]

> chk(sABCD[nm], sACD[nm])

> chk(sABCD$lower["A", , drop = FALSE], sACD$lower)

> chk(sABCD$upper["A", , drop = FALSE], sACD$upper)

> sABCD$lower["B", ]
[1] 0 0 0

> sABCD$upper["B", ]
[1] 0 0 0

> J <- 6

> K <- 3

> B <- matrix(rnorm(J * K), nrow = J)

> D <- runif(J)

> S <- tcrossprod(B) + diag(D)

> Linv <- t(chol(S))

> Linv <- ltMatrices(Linv[lower.tri(Linv, diag = TRUE)], 
+     diag = TRUE)

> a <- -(2 + runif(J))

> b <- 2 + runif(J)

> M <- 1e+06

> dim(w <- matrix(runif((J - 1) * M), nrow = J - 1))
[1]       5 1000000

> lpmvnorm(lower = a, upper = b, chol = Linv, w = w)
[1] -1.138

> dim(Z <- matrix(rnorm(K * M), nrow = K))
[1]       3 1000000

> lpRR(lower = a, upper = b, B = B, D = D, Z = Z)
[1] -1.139

> smv <- slpmvnorm(lower = a, upper = b, chol = Linv, 
+     w = w)

> sRR <- slpRR(lower = a, upper = b, B = B, D = D, Z = Z)

> chk(c(smv$lower), sRR$lower, tolerance = 0.01)

> chk(c(smv$upper), sRR$upper, tolerance = 0.01)

> chk(c(smv$mean), sRR$mean, tolerance = 0.01)

> Z <- matrix(rnorm(K * 1000), nrow = K)

> lB <- function(B) lpRR(lower = a, upper = b, B = B, 
+     D = D, Z = Z)

> gB <- grad(lB, B)

> sRR <- slpRR(lower = a, upper = b, B = B, D = D, Z = Z)

> chk(gB, c(sRR$B), tolerance = 0.001)

> lD <- function(D) lpRR(lower = a, upper = b, B = B, 
+     D = D, Z = Z)

> gD <- grad(lD, D)

> chk(gD, c(sRR$D), tolerance = 0.001)

> llwr <- function(a) lpRR(lower = a, upper = b, B = B, 
+     D = D, Z = Z)

> glwr <- grad(llwr, a)

> chk(glwr, c(sRR$lower))

> lupr <- function(b) lpRR(lower = a, upper = b, B = B, 
+     D = D, Z = Z)

> gupr <- grad(lupr, b)

> chk(gupr, c(sRR$upper))

 *** Run successfully completed ***
> proc.time()
   user  system elapsed 
 14.835   0.239  15.073 
